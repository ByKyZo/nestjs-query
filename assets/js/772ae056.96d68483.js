(window.webpackJsonp=window.webpackJsonp||[]).push([[54],{127:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return i})),n.d(t,"metadata",(function(){return a})),n.d(t,"toc",(function(){return c})),n.d(t,"default",(function(){return p}));var o=n(3),s=n(7),r=(n(0),n(215)),i={title:"Testing Services"},a={unversionedId:"persistence/typeorm/testing-services",id:"persistence/typeorm/testing-services",isDocsHomePage:!1,title:"Testing Services",description:"It is possible to test services that use TypeOrmQueryService. The process is similar to the one described for nestjs, but it has a few differences.",source:"@site/docs/persistence/typeorm/testing-services.md",slug:"/persistence/typeorm/testing-services",permalink:"/nestjs-query/docs/persistence/typeorm/testing-services",editUrl:"https://github.com/doug-martin/nestjs-query/edit/master/documentation/docs/persistence/typeorm/testing-services.md",version:"current",sidebar:"docs",previous:{title:"Soft Delete",permalink:"/nestjs-query/docs/persistence/typeorm/soft-delete"},next:{title:"Getting Started",permalink:"/nestjs-query/docs/persistence/sequelize/getting-started"}},c=[{value:"Mocking Inherited Methods",id:"mocking-inherited-methods",children:[]}],d={toc:c};function p(e){var t=e.components,n=Object(s.a)(e,["components"]);return Object(r.b)("wrapper",Object(o.a)({},d,n,{components:t,mdxType:"MDXLayout"}),Object(r.b)("p",null,"It is possible to test services that use ",Object(r.b)("inlineCode",{parentName:"p"},"TypeOrmQueryService"),". The process is similar to the one described for ",Object(r.b)("a",{parentName:"p",href:"https://docs.nestjs.com/techniques/database#testing"},"nestjs"),", but it has a few differences."),Object(r.b)("p",null,"Let's assume we have the following ",Object(r.b)("inlineCode",{parentName:"p"},"TodoItem")," service. For the sake of completeness, let's also add a dependency on another service (let's pretend that the todos have subTasks; we are not using relationships here):"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-ts",metastring:'title="todo-item.service.ts"',title:'"todo-item.service.ts"'},"import { InjectQueryService, QueryService } from '@nestjs-query/core';\nimport { TypeOrmQueryService } from '@nestjs-query/query-typeorm';\nimport { Repository } from 'typeorm';\nimport { InjectRepository } from '@nestjs/typeorm';\nimport { SubTaskEntity } from '../sub-task/sub-task.entity';\nimport { TodoItemEntity } from './todo-item.entity';\n\n@QueryService(TodoItemEntity)\nexport class TodoItemService extends TypeOrmQueryService<TodoItemEntity> {\n  constructor(\n    @InjectRepository(TodoItemEntity) private todosRepository: Repository<TodoItemEntity>,\n    @InjectQueryService(SubTaskEntity) private subTaskService: QueryService<SubTaskEntity>,\n  ) {\n    super(todosRepository);\n  }\n\n  async getWithSubTasks(id: number): Promise<{ todoItem: TodoItemEntity; subTasks: SubTaskEntity[] }> {\n    const todoItem = await this.todosRepository.findOneOrFail(id);\n    const subTasks = await this.subTaskService.query({ filter: { todoItemId: { eq: id } } });\n    return { todoItem, subTasks };\n  }\n}\n\n")),Object(r.b)("p",null,"Now lets writ a some tests! "),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-ts",metastring:'title="todo-item.service.spec.ts"',title:'"todo-item.service.spec.ts"'},"import { Test, TestingModule } from '@nestjs/testing';\nimport { getQueryServiceToken } from '@nestjs-query/core';\nimport { getRepositoryToken } from '@nestjs/typeorm';\nimport { plainToClass } from 'class-transformer';\nimport { TodoItemEntity } from '../src/todo-item/todo-item.entity';\nimport { SubTaskEntity } from '../src/sub-task/sub-task.entity';\nimport { TodoItemService } from '../src/todo-item/todo-item.service';\n\n// We create some fake entiites, just for testing. Here they are empty,\n// but they can be more complex, depending on the testing cases.\nconst subTasks = [new SubTaskEntity(), new SubTaskEntity(), new SubTaskEntity()];\nconst oneTodo: TodoItemEntity = plainToClass(TodoItemEntity, { id: 1, title: 'A test todo' });\n\ndescribe('TodosItemService', () => {\n  let service: TodoItemService; // Removed type, compared to the nestjs examples\n\n  // We mock the responses of the two services. \n  // The mocks in this example are very simple, but they can be more complex, depending on the test cases.\n\n  const mockedSubTaskService = {\n    // mock the query method that is used by getWithSubTasks\n    query: jest.fn((query) => Promise.resolve(subTasks)),\n  };  \n  const mockedRepo = {\n    // mock the repo `findOneOrFail`\n    findOneOrFail: jest.fn((id) => Promise.resolve(oneTodo)),\n  };\n\n  beforeEach(async () => {\n    const module: TestingModule = await Test.createTestingModule({\n      providers: [\n        // Provide the original service\n        TodoItemService,\n        // Mock the repository using the `getRepositoryToken` from @nestjs/typeorm\n        {\n          provide: getRepositoryToken(TodoItemEntity),\n          useValue: mockedRepo,\n        },\n        // Mock the SubTask QueryService using the `getQueryServiceToken` from @nestjs-query/core\n        {\n          provide: getQueryServiceToken(SubTaskEntity),\n          useValue: mockedSubTaskService,\n        },\n      ],\n    }).compile();\n    // get the service from the testing module.\n    service = await module.get(TodoItemService);\n  });\n\n  // reset call counts and called with arguments after each spec\n  afterEach(() => jest.clearAllMocks());\n\n  // Now we are ready to write the tests.\n  describe('getWithSubTasks', () => {\n    it('should return a TodoItem with subTasks', async () => {\n      // We can use jest spies to inspect if functions are called ...\n\n      // create a spy for the repository findOneOrFail method\n      const findOneOrFailSpy = jest.spyOn(mockedRepo, 'findOneOrFail');\n      // create a spy for the mocked subTaskService query method\n      const querySpy = jest.spyOn(mockedSubTaskService, 'query');\n\n      // When we call a service function the following things happen:\n      // - the real service function is called, so we can test its code\n      // - the mocked repository method is called\n      // - the mocked subTask query service method is called\n      // note that if the service calls a function in a repo or query service that is not defined by a mock, the test\n      // will fail\n      const todo = await service.getWithSubTasks(oneTodo.id);\n      // check the result against the expected results\n      expect(todo).toEqual({ todoItem: oneTodo, subTasks });\n\n      // Ensure that the spies are called once with the appropriate arguments\n      expect(findOneOrFailSpy).toHaveBeenCalledTimes(1);\n      expect(findOneOrFailSpy).toHaveBeenCalledWith(oneTodo.id);\n      expect(querySpy).toHaveBeenCalledTimes(1);\n      expect(querySpy).toHaveBeenCalledWith({ filter: { todoItemId: { eq: oneTodo.id } } });\n    });\n  });\n});\n\n")),Object(r.b)("h2",{id:"mocking-inherited-methods"},"Mocking Inherited Methods"),Object(r.b)("p",null,"You can also mock inherited methods."),Object(r.b)("p",null,"Let's change the ",Object(r.b)("inlineCode",{parentName:"p"},"getWithSubTasks")," method from the ",Object(r.b)("inlineCode",{parentName:"p"},"TodoItemService")," to use the ",Object(r.b)("inlineCode",{parentName:"p"},"getById")," method from the parent ",Object(r.b)("inlineCode",{parentName:"p"},"TypeOrmQueryService")),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-ts"},"async getWithSubTasks(id: number): Promise<{ todoItem: TodoItemEntity; subTasks: SubTaskEntity[] }> {\n  const todoItem = await this.getById(id);\n  const subTasks = await this.subTaskService.query({ filter: { todoItemId: { eq: id } } });\n  return { todoItem, subTasks };\n}\n")),Object(r.b)("p",null,"To mock the ",Object(r.b)("inlineCode",{parentName:"p"},"getById")," method we can create a new ",Object(r.b)("inlineCode",{parentName:"p"},"spy")," with a mock implementation"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-ts"},"const getByIdSpy = jest.spyOn(service, 'getById').mockImplementation(() => Promise.resolve(oneTodo));\n")),Object(r.b)("p",null,"Lets update our tests to mock out the ",Object(r.b)("inlineCode",{parentName:"p"},"getById")," implementation"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-ts"},"describe('getWithSubTasks', () => {\n  it('should return a TodoItem with subTasks', async () => {\n    // We can use jest spies to inspect if functions are called ...\n\n    // create a mock implementation for getById on the service\n    const getByIdSpy = jest.spyOn(service, 'getById').mockImplementation(() => Promise.resolve(oneTodo));\n    // create a spy for the mocked subTaskService query method\n    const querySpy = jest.spyOn(mockedSubTaskService, 'query');\n\n    // When we call a service function the following things happen:\n    // - the real service function is called, so we can test its code\n    // - the mock todoItem query service method is called\n    // - the mocked subTask query service method is called\n    // note that if the service calls a function in a repo or query service that is not defined by a mock, the test\n    // will fail\n    const todo = await service.getWithSubTasks(oneTodo.id);\n    // check the result against the expected results\n    expect(todo).toEqual({ todoItem: oneTodo, subTasks });\n\n    // Ensure that the spies are called once with the appropriate arguments\n    expect(getByIdSpy).toHaveBeenCalledTimes(1);\n    expect(getByIdSpy).toHaveBeenCalledWith(oneTodo.id);\n    expect(querySpy).toHaveBeenCalledTimes(1);\n    expect(querySpy).toHaveBeenCalledWith({ filter: { todoItemId: { eq: oneTodo.id } } });\n  });\n\n  it('should reject if the getById rejects with an error', async () => {\n    // We can use jest spies to inspect if functions are called ...\n\n    // create a mock implementation for the service getById method\n    const getByIdSpy = jest.spyOn(service, 'getById').mockImplementation(() => Promise.reject(new Error('foo')));\n    // create a spy for the mocked subTaskService query method\n    const querySpy = jest.spyOn(mockedSubTaskService, 'query');\n\n    // When we call a service function the following things happen:\n    // - the real service function is called, so we can test its code\n    // - the mocked repository method is called\n    // - the mocked subTask query service method is called\n    // note that if the service calls a function in a repo or query service that is not defined by a mock, the test\n    // will fail\n    await expect(service.getWithSubTasks(oneTodo.id)).rejects.toThrow('foo');\n\n    // Ensure that the getById spy is called one\n    expect(getByIdSpy).toHaveBeenCalledTimes(1);\n    expect(getByIdSpy).toHaveBeenCalledWith(oneTodo.id);\n    // Ensure that that the querySpy was not called  \n    expect(querySpy).not.toHaveBeenCalled();\n  });\n});\n")))}p.isMDXComponent=!0},215:function(e,t,n){"use strict";n.d(t,"a",(function(){return l})),n.d(t,"b",(function(){return y}));var o=n(0),s=n.n(o);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,o,s=function(e,t){if(null==e)return{};var n,o,s={},r=Object.keys(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||(s[n]=e[n]);return s}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(s[n]=e[n])}return s}var d=s.a.createContext({}),p=function(e){var t=s.a.useContext(d),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},l=function(e){var t=p(e.components);return s.a.createElement(d.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return s.a.createElement(s.a.Fragment,{},t)}},u=s.a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,i=e.parentName,d=c(e,["components","mdxType","originalType","parentName"]),l=p(n),u=o,y=l["".concat(i,".").concat(u)]||l[u]||m[u]||r;return n?s.a.createElement(y,a(a({ref:t},d),{},{components:n})):s.a.createElement(y,a({ref:t},d))}));function y(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=u;var a={};for(var c in t)hasOwnProperty.call(t,c)&&(a[c]=t[c]);a.originalType=e,a.mdxType="string"==typeof e?e:o,i[1]=a;for(var d=2;d<r;d++)i[d]=n[d];return s.a.createElement.apply(null,i)}return s.a.createElement.apply(null,n)}u.displayName="MDXCreateElement"}}]);